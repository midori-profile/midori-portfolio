---
title: "Uni-Code: Leveraging Monorepo for Enhanced Collaboration and Efficiency"
publishedAt: '2022-12-15'
summary: ''
---

## Introduction

In the software development process, the way codes are organized directly impacts team collaboration efficiency. 
There are two mainstream code management strategies: ``Multi-repo`` and `Monorepo`. 
In this article, we will discuss how we use a `Monorepo` to replace the original multi-repository approach for Tencent Cloud Operating System.

## What is Monorepo?

A `Monorepo` is a project management strategy that allows multiple projects or modules to be stored within a single shared code repository, whereas `Multi-repo` means each project or module resides in its own separate repository.

## Why do we need to use Monorepo in our business?

Before discussing `Monorepo`, it's important to understand some `Multi-repo's` shortcomings that `Monorepo` aims to address.

### Shortcomings of Multi-repo:

1. **Code Reuse Sometimes Causes Trouble:**
   In our case, we had similar apps deployed on different platforms, with a lot of repetitive codes. 
   <Image
   alt={`Website`}
   src={`/images/uni-code/uni-3.jpg`}
   width={800}
   height={200}
   />

   An enum definition can repeat 10 times, including many outdated definitions.

   When a common module changed, updating all modules that depend on it became a cumbersome task. 
   
   Additionally, because code was dispersed across various locations, searching through repositories often added considerable pain to the team.

2. **Complex Publish Management:**

   In a multi-repo environment, changes to each project or module are recorded independently, making it exceptionally difficult to understand the entire system's change history. 
   
   Automation tools struggle to link changes across repositories, thereby affecting the efficiency of version management and release processes.

### Advantages of Using Monorepo:

<ProsCard 
  pros={[
    "Simplified Code Reuse: Since all projects reside within the same repository, sharing and reusing code becomes incredibly simple. We can reference packages at the code level, which also makes debugging much more convenient. Configuration files such as .eslintrc and tsconfig also can be reused. This means any engineering practice can be rapidly and effortlessly adopted across the entire team.",
    "Global Changelog: With Monorepo, the change logs of all projects can be managed collectively, simplifying the creation of a global Changelog. This is beneficial for tracking the historical changes of the entire project group, managing releases, and troubleshooting.",
  ]}
/>

## Now, Let's Establishing an Efficient Monorepo for Business

<Callout emoji="ğŸ’¡">
The codebase is open-source. You can explore it [here on GitHub](https://github.com/midori-profile/uni-code).
</Callout>


<Image
  alt={`Website`}
  src={`/images/uni-code/uni-2.jpg`}
  width={800}
  height={200}
/>

### Challenges


While Monorepo offers numerous advantages, fully unleashing its potential requires careful implementation. Here were some primary challenges our business faced:

> Fundamental Challenges:

1. **Dependency Tool Decision:**
   Our previous shared package was using yarn + lerna. Should we stick with it, or shift to pnpm?

2. **Cross-Project Modules Management:**
   When modules are used across front-end and back-end projects, it's vital to design a robust package structure. Creating a shared package that works seamlessly across various environments (e.g., Web, mini-apps, Node.js, Vite, Webpack) and addresses compatibility issues.

> Advanced Challenges:

3. **Changelog Management:**
   If each project has it's own changelog and independent pipelines, there will be huge management and maintenance costs. Therefore, standardized Changelog and standard pipeline are needed .

4. **Server-Side Rendering (SSR) Support**

5. **Adopting Mixed-Language Development (TypeScript/Rust):**
   Using multiple programming languages â€‹â€‹(such as TypeScript and Rust) is an effective way to improve performance. Can we find a way to organize and manage code in different languages â€‹â€‹in `Monorepo`?

## Letâ€™s talk about the solutions to each problem one by one:

### I. **Dependency Tool Selection:**

<Table
  data={{
    headers: [
      'Feature',
      'Lerna + Yarn',
      'pnpm',
    ],
    rows: [
      [
        'Learning Curve',
        'High, requires mastering the combination of two tools',  
        'Low, simplified configuration and built-in commands make it quicker to get started'
      ],
      [
        'Release Speed',
        'Slow, even updating a single package requires installing and building dependencies of all packages',  
        'Fast, reduces unnecessary installation and build through shared dependencies'
      ],
      [
        'Dependency Management',
        'Phantom dependencies issue, increasing runtime risks',  
        'Avoids accessing undeclared dependencies through a non-flattened `node_modules` structure'
      ],
      [
        'Dependency Conflict Handling',
        'When conflicts arise, yarn duplicate repeatedly packages compatible versions to resolve them.',  
        'Effectively avoids conflicts through symlink technology'
      ],
      [
        'Support for `Monorepo`',
        'Requires additional configuration and management to adapt to `Monorepo`',  
        'Naturally suitable for `Monorepo`, e.g., referencing a workspace package named `foo` with `foo:workspace`'
      ],
      [
        'Multi-package Version Management and Release',
        'Powerful, designed for managing multiple packages in a `Monorepo`, offering detailed version control and release process',  
        'Requires additional script support'
      ],
      [
        'Community Support and Maturity',
        'Mature ecosystem',  
        'Still relatively new in the community'
      ],
    ],
  }}
/>


#### Conclusion: Choose pnpm

Considering the significant advantages of `pnpm` in terms of dependency management efficiency, security, and natural support for `Monorepo`, we have concluded that choosing `pnpm` as our dependency management tool is the superior decision.

### II. **Cross-Project Modules Management:**

### 2.1 Module System Selection

  The evolution of JavaScript module systems can be summarized as follows: CommonJS (CJS) â†’ Asynchronous Module Definition (AMD) â†’ Common Module Definition (CMD) â†’ ECMAScript Modules (ESM).

  Currently, AMD and CMD are relatively complex and lack sufficient support from build tools, making them less popular module systems.

  When designing a monorepo, it is essential to choose the appropriate module system to ensure seamless code integration across applications. Here, we will compare various module bundling methods to determine the best fit for our monorepo structure.

<Table
  data={{
    headers: [
      'Feature',
      'ESM (ES Modules)',
      'CJS (CommonJS)',
    ],
    rows: [
      [
        'Standardization',
        'JavaScript official standardized module system',
        'CommonJS, currently the most used module system in Node.js'
      ],
      [
        'Usage',
        '1. Browser    2. Node.js â‰¥ 12.17',
        '1. Node.js 2. Front-end projects (with build tools like Webpack or Rollup'
      ],
      [
        'Tree Shaking',
        'Facilitates tree shaking',
        'Not friendly for tree shaking'
      ],
    ],
  }}
/>

After understanding these module types, the best practices for choosing module specifications are as follows:

  - **Shared Configuration Modules (Cross Frontend and Backend)**: Publish packages in both ESM and CJS formats. While ESM is the modern choice, CJS remains a fallback option due to the ongoing improvements in Node.js support for ESM.

  - **UI Component Libraries**: Publish packages in both ESM and CJS formats. This ensures that the component libraries can be used in various development environments, whether in frontend frameworks like React or Vue or with bundling tools like Webpack or Rollup.

  - **For Node.js Projects**: Currently, only publish packages in CJS format. CJS is the default module system in Node.js, offering stable and extensive support, making it suitable for most backend project needs.

  - **Compatibility**: Ensure that the modules run seamlessly in the target runtime environment. Projects that need to support older browsers or Node.js versions may require additional transpilation steps (such as using Babel).

### 2.2 Package Structure Design

We need to design a monorepo that supports `backend projects`, `frontend component libraries`, `frontend projects`, and `cross-frontend and backend libraries`. Therefore, we have designed the directory structure as follows:

```plaintext
/monorepo
â”‚
â”œâ”€â”€ /apps/                   # Frontend and backend applications
â”‚   â”œâ”€â”€ /client/             # Frontend applications
â”‚   â”‚   â”œâ”€â”€ next-app         # Next.js project(a React framework with server-side rendering capabilities)
â”‚   â”‚   â”œâ”€â”€ react-app        # React project
â”‚   â”‚   â”œâ”€â”€ uni-app          # uni-app (a vue-based framework)
â”‚   â”‚   â”œâ”€â”€ vite-app         # Vite project
â”‚   â”‚   â”œâ”€â”€ vite-react-app   # Vite and React project
â”‚   â”‚
â”‚   â”œâ”€â”€ /service/            # Backend services
â”‚       â”œâ”€â”€ deno-app         # Backend project using Deno (a modern JavaScript/TypeScript runtime)
â”‚       â”œâ”€â”€ node-app         # Backend project using Node.js
â”‚
â”œâ”€â”€ /packages/               # Shared libraries
â”‚   â”œâ”€â”€ /config/             # Shared configuration modules
â”‚   â”œâ”€â”€ /utils/              # Shared utility modules
â”‚   â”‚   â”œâ”€â”€ /native/         # Native modules (Rust/C++)
â”‚   â”‚   â”œâ”€â”€ /js/             # js utils shared across front-end and back-end projects
â”‚   â”‚   â”œâ”€â”€ /tests/          # Test code
â”‚   â”‚   â”œâ”€â”€ package.json     # Project configuration file
â”‚   â”‚
â”‚   â”œâ”€â”€ /ui/                 # Component libraries
â”‚   â”‚   â”œâ”€â”€ /react/          # React components
â”‚   â”‚   â”œâ”€â”€ /vue/            # Vue components
â”‚
â”œâ”€â”€ /scripts/                # Scripts
â”‚   â”œâ”€â”€ build.js             # Build script
â”‚   â”œâ”€â”€ deploy.js            # Deployment script
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ package.json             # Root-level project configuration file
â”œâ”€â”€ pnpm-workspace.yaml      # PNPM workspace configuration file
```

We have also established a CLI tool: a command-line interface based on **Commander + Inquirer + Chalk**. The related commands are already written into the custom command set of the monorepo. Running `pnpm create` initializes the setup, and there are corresponding templates for common library projects, UI library projects, and frontend/backend seed repositories.

**Inquirer.js** is a Node.js library that makes it easy to create interactive command-line prompts.

**Chalk** is a Node.js library that allows you to style text in the command-line.

### 2.3 Designing a Shared Package

Now, we will cover how to configure and package shared modules or application projects in a Monorepo. We'll start with shared modules and then move to an example application, such as a React project. 

#### 2.3.1. Shared Modules

When packaging cross-platform utilities, we should support both CommonJS (CJS) and ES Modules (ESM), as concluded previously. In our project, we use `tsup` for its simplicity and speed.

**Tsup Configuration Example:**

```typescript
// packages/utils/tsup.config.ts
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['utils/index.ts', 'types/index.ts'],
  clean: true,
  dts: true,
  outDir: 'dist',
  format: ['cjs', 'esm']
});
```

**package.json Configuration for utilities:**

```json
{
  "name": "@infras/shared",
  "version": "0.0.1",
  "description": "Shared utilities for all projects and apps.",
  "exports": {
    "./utils": {
      "import": "./dist/utils/index.mjs",
      "require": "./dist/utils/index.js"
    },
    "./types": {
      "import": "./dist/types/index.mjs",
      "require": "./dist/types/index.js"
    }
  },
  "main": "dist/index.js",
  "module": "dist/index.mjs",
  "typings": "dist/index.d.ts",
  "sideEffects": false,
  "scripts": {
    "prepare": "npm run build",
    "dev": "tsup --watch",
    "build": "tsup"
  },
  "devDependencies": {
    "tsup": "^5.10.3"
  }
}
```
#### 2.3.2. Packaging UI Component Library

For a UI component library, the packaging process is similar to utilities. We need to support both CJS and ESM formats and ensure TypeScript definitions are included.

**Tsup Configuration for UI Components:**

```typescript
// packages/ui/tsup.config.ts
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['components/index.ts'],
  clean: true,
  dts: true,
  outDir: 'dist',
  format: ['cjs', 'esm']
});
```

**package.json Configuration for UI Components:**

```json
{
  "name": "@infras/ui",
  "version": "0.0.1",
  "description": "UI component library for all projects and apps.",
  "exports": {
    "./components": {
      "import": "./dist/components/index.mjs",
      "require": "./dist/components/index.js"
    }
  },
  "main": "dist/index.js",
  "module": "dist/index.mjs",
  "typings": "dist/index.d.ts",
  "sideEffects": false,
  "scripts": {
    "prepare": "npm run build",
    "dev": "tsup --watch",
    "build": "tsup"
  },
  "devDependencies": {
    "tsup": "^5.10.3"
  }
}
```
### 2.4 Application Example: React Project

**Packaging and Configuring package.json**

For the application, such as a React project, we'll configure the `package.json` to include the necessary dependencies and scripts.

```json
{
  "name": "react-app",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^17.0.0",
    "react-dom": "^17.0.0",
    "@infras/shared": "workspace:*",
    "@infras/ui": "workspace:*"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "devDependencies": {
    "react-scripts": "^4.0.3"
  }
}
```
#### 2.4.2. Importing Shared Packages in React Project

In the React application, you can import the shared utilities and UI components as follows:

```javascript
// src/index.tsx
import React from 'react';
import ReactDOM from 'react-dom';
import { AppType } from '@infras/shared/types';
import { sum } from '@infras/shared/utils';
import { Button } from '@infras/ui/components';

const App = () => (
  <div>
    <h1>App Type: {AppType.Web}</h1>
    <p>Sum: {sum(1, 2)}</p>
    <Button>Click Me</Button>
  </div>
);

ReactDOM.render(<App />, document.getElementById('root'));
```
### 2.5 Additional Considerations ğŸ‘€

Workspace Configuration:

We use PNPM, which natively supports workspaces. A workspace is a set of related projects managed within one repository and benefits seamless integration between them. PNPM workspace allows easy linking of workspace projects, directly depending on the code level, rather than having to use package management / cross-repository dependencies. No need for version management.
**Example pnpm-workspace.yaml:**

```yaml
# This YAML file configures the workspace for PNPM.
# It specifies the locations of the packages within the monorepo.
packages:
  - 'apps/*'
  - 'packages/*'
```

**Shared Dependencies:**

Define shared dependencies at the root level.

**Root package.json:**

```json
{
  "name": "monorepo",
  "private": true,
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "dependencies": {
    "react": "^17.0.0",
    "react-dom": "^17.0.0"
  },
  "devDependencies": {
    "eslint": "^8.5.0",
    "prettier": "^2.3.2"
  }
}
```
For open collaboration on shared packages: it is more convenient to actively submit code for projects of other groups, such as fixing defects or implementing new features we need. However, to avoid issues brought by open collaboration,

Code modifications should consider backward compatibility as much as possible
After the modification is completed, automatically run unit tests of the relevant caller
When merging requests, identify modifications to the relevant public library and automatically set the corresponding person in charge as a necessary reviewer
Notify the testing team to conduct relevant system tests and core regression tests
### 2.6 How to Run:

  - React project: pnpm start --filter "react-app"

  - Node.js project: pnpm start --filter "node-app"

  - Vite project: pnpm start --filter "vite-app"

### III. **Changelog Management:**

Managing changelogs in a monorepo can be challenging due to the complexity of handling multiple projects with independent update cycles.

We chose `changesets` to tackle this challenge. `changesets` is recommended by pnpm, and after our investigation, we discovered that the TikTok FE team also relies on it.

Here's how `changesets` works:

Each change creates a new Changeset to describe the modifications made to a particular package, thus managing version numbers.

When a package fixes a bug, `changesets` records the bug fix and updates the package's version to a new release. If other packages depend on this package, `changesets` records this version change in the Changeset of these dependent packages and updates their version numbers accordingly.

If multiple Changesets simultaneously modify the dependencies of the same package, `changesets` automatically merges these changes and ensures that the final dependency relationship remains valid.


#### ä¸‹é¢å¤§è‡´ä»‹ç»ä¸€ä¸‹æˆ‘ä»¬æ˜¯å¦‚ä½•Using Changesets with PNPM

**Step 1: Install Changesets**

Install Changesets as a dev dependency in your monorepo

```bash
# in the root directory
pnpm add @changesets/cli -D
```

**Step 2: Initialize Changesets**

Initialize Changesets in your repository,create a `.changeset` folder in the root of your repository with some configuration files.

```bash
pnpm changeset init
```

**Step 3: Configure Changesets**

Edit the `.changeset/config.json` file 

```json
{
  "changelog": ["@changesets/changelog-github", { "repo": "your-org/your-repo" }],
  "commit": false, // Specifies whether to automatically commit changesets.
  "fixed": [], // Specifies any fixed changeset versions.
  "linked": [], // Specifies linked changeset versions.
  "access": "public", // The access level for published packages.
  "baseBranch": "main", // The base branch for version bumps.
  "updateInternalDependencies": "patch", // Specifies how to update internal dependencies.
  "ignore": [] // Specifies any files to ignore when creating changesets.
}
```

**Step 4: Versioning and Publishing**

ç°åœ¨ä½ å¯ä»¥æ­£å¸¸çš„å¼€å‘ä½ çš„ä»£ç ï¼Œæäº¤ commit
When you are ready to release a new version, run the following command to bump versions and update the changelog:

```bash
pnpm changeset version
```
When the **`pnpm changeset publish`** command is run, the changeset tool will compare the current state of the **`my-package`** package with the previous version stored in the version control system. If any changes are detected, the changeset tool will increment the version of the package based on the type of changes made

the version of a package is updated based on the type of changes made to the package. For example, if a change is considered a "breaking" change, the version of the package would be updated to a new major version.

This command will:

1. Update the versions of the changed packages.
2. Generate a new changelog entry.
3. Commit the changes.

After versioning, you can publish the packages to the registry:

```bash
pnpm publish -r
```

**Step 6: Automating with CI/CD**

You can automate the versioning and publishing process using CI/CD tools ï¼Œè¿™é‡Œæˆ‘ä»¬ç”¨ GitHub Actionsä½œä¸ºä¸€ä¸ªç¤ºä¾‹. Hereâ€™s an example workflow file (`.github/workflows/release.yml`) for GitHub Actions:

```yaml
name: Release

on:
  push:
    branches:
      - main

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Create and publish changeset
        run: |
          pnpm changeset version
          git config --global user.email "you@example.com"
          git config --global user.name "Your Name"
          git add .
          git commit -m "chore(release): version packages"
          git push
          pnpm publish -r
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

**Summary**

è¿™å°±æ˜¯ä½¿ç”¨ changeset çš„è¿‡ç¨‹ï¼Œé€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬å¯ä»¥æ›´å¥½çš„ç®¡ç† monorepo ä¸­çš„ changelogï¼Œç¡®ä¿ç‰ˆæœ¬çš„ä¸€è‡´æ€§å’Œå¯è¿½æº¯æ€§ã€‚

### IIII. **ç»„ä»¶åº“æ”¯æŒæœåŠ¡ç«¯æ¸²æŸ“ SSR:**

#### ç»„ä»¶åº“æ‰“åŒ…

åœ¨è®¾è®¡å’Œæ‰“åŒ…ç»„ä»¶åº“æ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›ç»„ä»¶åº“èƒ½å¤Ÿå…¼å®¹å¤šç§ç¯å¢ƒï¼ŒåŒ…æ‹¬æµè§ˆå™¨å’Œ Node.js æœåŠ¡å™¨ç«¯æ¸²æŸ“ (SSR)ã€‚è¿™é‡Œä»¥ `@infras/ui` ä¸ºä¾‹ï¼Œä»‹ç»ç»„ä»¶åº“çš„æ‰“åŒ…å’Œä½¿ç”¨ã€‚

##### æ‰“åŒ…é…ç½®ç¤ºä¾‹

é¦–å…ˆï¼Œæˆ‘ä»¬ä½¿ç”¨ `tsup` è¿›è¡Œæ‰“åŒ…ï¼Œç”Ÿæˆ ESM å’Œ CJS æ ¼å¼çš„åŒ…ï¼ŒåŒæ—¶ç”Ÿæˆç±»å‹å®šä¹‰æ–‡ä»¶ï¼š

```typescript
// packages/ui/tsup.config.ts
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['react/index.ts', 'vue/index.ts'],
  clean: true,
  dts: true,
  outDir: 'dist',
  format: ['cjs', 'esm'],
  external: ['react', 'vue']
});
```

æ‰§è¡Œ `tsup` åï¼Œä¼šç”Ÿæˆ `dist` ç›®å½•ï¼Œç»“æ„å¦‚ä¸‹ï¼š

```
# packages/ui
- dist
  - react
    - index.js (CJS)
    - index.mjs (ESM)
    - index.d.ts (TypeScript)
  - vue
    - index.js (CJS)
    - index.mjs (ESM)
    - index.d.ts (TypeScript)
- react
  - index.ts
- vue
  - index.ts
- package.json
```

##### package.json é…ç½®

ç»„ä»¶åº“çš„ `package.json` é…ç½®å¦‚ä¸‹ï¼š

```json
// packages/ui/package.json
{
  "name": "@infras/ui",
  "version": "0.0.1",
  "description": "A UI component library for React and Vue.",
  "main": "dist/react/index.js",
  "module": "dist/react/index.mjs",
  "exports": {
    "./react": {
      "import": "./dist/react/index.mjs",
      "require": "./dist/react/index.js"
    },
    "./vue": {
      "import": "./dist/vue/index.mjs",
      "require": "./dist/vue/index.js"
    }
  },
  "typings": "dist/index.d.ts",
  "sideEffects": false,
  "scripts": {
    "build": "tsup"
  },
  "devDependencies": {
    "tsup": "^5.10.3"
  },
  "peerDependencies": {
    "react": "^17.0.0 || ^18.0.0",
    "vue": "^3.0.0"
  }
}
```

### ç»„ä»¶åº“åœ¨å‰ç«¯åº”ç”¨ä¸­çš„ä½¿ç”¨

##### é Vite åº”ç”¨é…ç½®

è‹¥ä¸æ˜¯ Vite åº”ç”¨ï¼Œéœ€è¦é…ç½® `dependenciesMeta` ç¡®ä¿æ­£ç¡®å¼•å…¥ç»„ä»¶åº“ï¼š

```json
// apps/*/package.json
{
  "dependencies": {
    "@infras/ui": "workspace:*"
  },
  "dependenciesMeta": {
    "@infras/ui": {
      "injected": true
    }
  }
}
```

##### åœ¨ React å’Œ Vue åº”ç”¨ä¸­å¼•å…¥ç»„ä»¶åº“

- **React åº”ç”¨**ï¼š
  ```typescript
  // apps/react-app/index.tsx
  import { Component } from '@infras/ui/react';

  const App = () => <Component />;
  export default App;
  ```

- **Vue åº”ç”¨**ï¼š
  ```vue
  <!-- apps/vue-app/index.vue -->
  <script setup lang="ts">
  import { Component } from '@infras/ui/vue';
  </script>

  <template>
    <Component />
  </template>
  ```

### ç»„ä»¶åº“æœåŠ¡ç«¯æ¸²æŸ“ (SSR)

ä¸ºäº†åœ¨ Node.js ç¯å¢ƒä¸‹æ”¯æŒæœåŠ¡ç«¯æ¸²æŸ“ (SSR)ï¼Œéœ€è¦ç¡®ä¿ç»„ä»¶åº“å¯ä»¥åœ¨æœåŠ¡å™¨ä¸Šè¿è¡Œï¼Œå¹¶æ­£ç¡®æ¸²æŸ“ç»„ä»¶ã€‚

- **React SSR**ï¼š
  ```javascript
  // apps/node-app/index.js
  const { Component } = require('@infras/ui/react');
  const React = require('react');
  const ReactDOMServer = require('react-dom/server');

  console.log('SSR: ', ReactDOMServer.renderToString(React.createElement(Component)));
  ```

### æ„å»ºä¸è¿è¡Œåº”ç”¨

- å¯åŠ¨ React åº”ç”¨ï¼š
  ```sh
  pnpm start --filter "react-app"
  ```

- å¯åŠ¨ Vue åº”ç”¨ï¼š
  ```sh
  pnpm start --filter "vite-app"
  ```

### ç»„ä»¶åº“æ‰“åŒ…ä¸ä½¿ç”¨åŸç†

1. **æ‰“åŒ…è¿‡ç¨‹**ï¼š
   - ä½¿ç”¨ `tsup` è¿›è¡Œæ‰“åŒ…ï¼ŒæŒ‡å®šå…¥å£æ–‡ä»¶å’Œè¾“å‡ºæ ¼å¼ï¼ˆESM å’Œ CJSï¼‰ã€‚
   - ç”Ÿæˆçš„æ–‡ä»¶ä¿å­˜åœ¨ `dist` ç›®å½•ä¸­ï¼Œå¹¶ç”Ÿæˆç±»å‹å®šä¹‰æ–‡ä»¶ä»¥ä¾¿åœ¨ TypeScript é¡¹ç›®ä¸­ä½¿ç”¨ã€‚

2. **ä½¿ç”¨è¿‡ç¨‹**ï¼š
   - åœ¨å‰ç«¯åº”ç”¨ä¸­ï¼Œé€šè¿‡é…ç½® `dependencies` å’Œ `dependenciesMeta` å¼•å…¥ç»„ä»¶åº“ã€‚
   - åœ¨ React å’Œ Vue åº”ç”¨ä¸­åˆ†åˆ«å¯¼å…¥ç»„ä»¶åº“ï¼Œå¹¶æŒ‰éœ€ä½¿ç”¨ç»„ä»¶ã€‚

3. **æœåŠ¡ç«¯æ¸²æŸ“**ï¼š
   - ç»„ä»¶åº“éœ€è¦æ”¯æŒåœ¨ Node.js ç¯å¢ƒä¸­è¿è¡Œï¼Œç¡®ä¿å¯ä»¥è¿›è¡ŒæœåŠ¡ç«¯æ¸²æŸ“ã€‚
   - å¯¹äº Reactï¼Œä½¿ç”¨ `react-dom/server` æ¸²æŸ“ç»„ä»¶ä¸ºå­—ç¬¦ä¸²ï¼Œå¹¶åœ¨æœåŠ¡å™¨ç«¯è¾“å‡ºã€‚

### Vue å’Œ React SSR åŸç†

- **React SSR åŸç†**ï¼š
  - ä½¿ç”¨ `ReactDOMServer.renderToString` æ–¹æ³•å°† React ç»„ä»¶æ¸²æŸ“ä¸º HTML å­—ç¬¦ä¸²ï¼Œç„¶ååœ¨æœåŠ¡å™¨ç«¯è¿”å›è¯¥å­—ç¬¦ä¸²ã€‚
  - è¿™ç§æ–¹å¼å¯ä»¥æé«˜é¦–å±æ¸²æŸ“é€Ÿåº¦ï¼Œå¹¶ä¸”æœ‰åˆ©äº SEOã€‚

- **Vue SSR åŸç†**ï¼š
  - Vue SSR ä½¿ç”¨ `vue-server-renderer` æä¾›çš„æ–¹æ³•å°† Vue ç»„ä»¶æ¸²æŸ“ä¸º HTML å­—ç¬¦ä¸²ã€‚
  - ç±»ä¼¼äº React çš„ `renderToString`ï¼ŒVue çš„ `renderToString` æ–¹æ³•ä¹Ÿå°†ç»„ä»¶æ¸²æŸ“ä¸º HTML å­—ç¬¦ä¸²ï¼Œç„¶ååœ¨æœåŠ¡å™¨ç«¯è¿”å›ã€‚

é€šè¿‡ä»¥ä¸Šé…ç½®å’Œæ–¹æ³•ï¼Œå¯ä»¥åœ¨ Monorepo é¡¹ç›®ä¸­é«˜æ•ˆåœ°æ„å»ºå’Œä½¿ç”¨ç»„ä»¶åº“ï¼Œå¹¶æ”¯æŒæœåŠ¡ç«¯æ¸²æŸ“ï¼Œæå‡åº”ç”¨æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚å¦‚æœæœ‰æ›´å¤šçš„å…·ä½“éœ€æ±‚æˆ–é—®é¢˜ï¼Œå¯ä»¥è¿›ä¸€æ­¥æ‰©å±•å’Œè‡ªå®šä¹‰è¿™äº›é…ç½®ã€‚

5. **Adopting Mixed-Language Development (TypeScript/Rust)**






### V. **Adopting Mixed-Language Development (TypeScript/Rust)**

åœ¨ Monorepo ä¸­ï¼Œä½¿ç”¨ Rust æˆ– Golang ç¼–å†™çš„ npm æ¨¡å—å¯ä»¥å¸®åŠ©å¤„ç†ä¸€äº› CPU å¯†é›†å‹ä»»åŠ¡ã€‚ä»¥ä¸‹æ˜¯å¦‚ä½•åœ¨ Monorepo é¡¹ç›®ä¸­é›†æˆå’Œä½¿ç”¨ Rust æ¨¡å—çš„è¯¦ç»†è¯´æ˜ã€‚

#### ä½¿ç”¨ Rust ç¼–å†™åŸç”Ÿè¯­è¨€æ¨¡å—

##### é¡¹ç›®ç›®å½•ç»“æ„

```
# packages/rs
- src
  - lib.rs
- npm
- index.js
- index.d.ts
- package.json
- Cargo.toml
```

##### åˆå§‹åŒ– Rust æ¨¡å—

ä½¿ç”¨ `napi-rs` åˆå§‹åŒ–ä¸€ä¸ª Rust æ„å»ºçš„ npm æ¨¡å—åŒ…ã€‚`napi-rs` é€‰æ‹©ç”¨ CJS æ ¼å¼æ¥å…¼å®¹ ESMï¼ˆç›¸å…³ node#40541ï¼‰ï¼Œæ— éœ€è¿›è¡Œé¢å¤–ä¿®æ”¹å³å¯ä½¿ç”¨ã€‚

##### package.json é…ç½®

ä»¥ä¸‹æ˜¯ `napi-rs` åˆå§‹åŒ–å‡ºæ¥çš„ `package.json` é…ç½®ï¼š

```json
// packages/rs/package.json
{
  "name": "@infras/rs",
  "version": "0.0.0",
  "type": "commonjs",
  "main": "index.js",
  "types": "index.d.ts",
  "devDependencies": {
    "@napi-rs/cli": "^2.0.0"
  },
  "scripts": {
    "prepare": "npm run build",
    "artifacts": "napi artifacts",
    "build": "napi build --platform --release",
    "build:debug": "napi build --platform",
    "version": "napi version"
  }
}
```

##### Rust ä»£ç ç¤ºä¾‹

åœ¨ `src/lib.rs` ä¸­ç¼–å†™ Rust ä»£ç ï¼Œä¾‹å¦‚ä¸€ä¸ªç®€å•çš„æ±‚å’Œå‡½æ•°ï¼š

```rust
#[macro_use]
extern crate napi_derive;

#[napi]
fn sum(a: i32, b: i32) -> i32 {
    a + b
}
```

##### Node.js åº”ç”¨ä¸­ä½¿ç”¨ Rust æ¨¡å—

åœ¨ Node.js åº”ç”¨ä¸­å£°æ˜åŸç”Ÿè¯­è¨€æ¨¡å—çš„ä¾èµ–ï¼š

```json
// apps/node-app/package.json
{
  "dependencies":{
     "@infras/rs": "workspace:*"
  }
}
```

åœ¨ Node.js åº”ç”¨ä¸­è°ƒç”¨ Rust æ¨¡å—ï¼š

- CommonJS æ¨¡å¼ï¼š

```javascript
// apps/node-app/index.js
const { sum } = require('@infras/rs');
console.log('Rust `sum(1, 1)`:', sum(1, 1)); // 2
```

- ESM æ¨¡å¼ï¼š

```javascript
// apps/node-app/index.mjs
import { sum } from '@infras/rs';
console.log('Rust `sum(1, 1)`:', sum(1, 1)); // 2
```

##### æ„å»ºå’Œè¿è¡Œ

ä½¿ç”¨ `napi-rs` æä¾›çš„å‘½ä»¤æ¥æ„å»º Rust æ¨¡å—ï¼š

```sh
cd packages/rs
pnpm run build
```

æ„å»ºå®Œæˆåï¼Œå¯ä»¥åœ¨ Node.js åº”ç”¨ä¸­è¿è¡Œå¹¶æµ‹è¯•ï¼š

```sh
pnpm start --filter "node-app"
```

é€šè¿‡è¿™ç§æ–¹å¼ï¼Œå¯ä»¥çœ‹åˆ° Rust ç¼–è¯‘åçš„å‡½æ•°æ‰§è¡Œæ•ˆç‡æ˜æ˜¾é«˜äº Node.js åŸç”Ÿå‡½æ•°ï¼ˆä¾‹å¦‚ï¼Œä» 8.44ms æå‡è‡³ 0.069msï¼‰ã€‚

### æ€»ç»“

é€šè¿‡åœ¨ Monorepo ä¸­é›†æˆ Rust æ¨¡å—ï¼Œå¯ä»¥æ˜¾è‘—æé«˜å¤„ç† CPU å¯†é›†å‹ä»»åŠ¡çš„æ€§èƒ½ã€‚ä»¥ä¸‹æ˜¯å…³é”®æ­¥éª¤çš„æ€»ç»“ï¼š

1. **åˆå§‹åŒ– Rust æ¨¡å—**ï¼š
   ä½¿ç”¨ `napi-rs` åˆå§‹åŒ–å¹¶é…ç½® `package.json` æ–‡ä»¶ã€‚
   
2. **ç¼–å†™ Rust ä»£ç **ï¼š
   åœ¨ `src/lib.rs` ä¸­ç¼–å†™éœ€è¦çš„åŠŸèƒ½å‡½æ•°ï¼Œå¹¶ä½¿ç”¨ `#[napi]` å®è¿›è¡Œæ ‡æ³¨ã€‚

3. **é…ç½® Node.js åº”ç”¨**ï¼š
   åœ¨ Node.js åº”ç”¨çš„ `package.json` ä¸­å£°æ˜å¯¹ Rust æ¨¡å—çš„ä¾èµ–ï¼Œå¹¶åœ¨ä»£ç ä¸­ä½¿ç”¨ `require` æˆ– `import` å¼•å…¥å¹¶è°ƒç”¨ Rust å‡½æ•°ã€‚

4. **æ„å»ºå’Œè¿è¡Œ**ï¼š
   ä½¿ç”¨ `napi-rs` æä¾›çš„è„šæœ¬æ„å»º Rust æ¨¡å—ï¼Œç„¶ååœ¨ Node.js åº”ç”¨ä¸­è¿è¡Œå¹¶æµ‹è¯•ã€‚

é€šè¿‡è¿™äº›æ­¥éª¤ï¼Œå¯ä»¥åœ¨ Monorepo é¡¹ç›®ä¸­æœ‰æ•ˆåœ°åˆ©ç”¨ Rust çš„é«˜æ€§èƒ½è®¡ç®—èƒ½åŠ›ï¼Œå¤„ç†å¤æ‚å’Œæ€§èƒ½è¦æ±‚é«˜çš„ä»»åŠ¡ã€‚

å¦‚æœæœ‰æ›´å¤šçš„å…·ä½“éœ€æ±‚æˆ–é—®é¢˜ï¼Œå¯ä»¥è¿›ä¸€æ­¥æ‰©å±•å’Œè‡ªå®šä¹‰è¿™äº›é…ç½®ã€‚

æ€»ç»“

è¿™å°±æ˜¯æˆ‘ä»¬å¦‚ä½•åœ¨Monorepoä¸­çµæ´»åœ°é›†æˆå’Œç®¡ç†å¤šç§ç±»å‹çš„é¡¹ç›®å’Œæ¨¡å—ï¼Œä»è€Œå®ç°é«˜æ•ˆçš„å¼€å‘å’Œåä½œã€‚

CommonJS åŠ è½½çš„æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼ˆå³module.exportså±æ€§ï¼‰ï¼Œè¯¥å¯¹è±¡åªæœ‰åœ¨è„šæœ¬è¿è¡Œå®Œæ‰ä¼šç”Ÿæˆã€‚

è€Œ ES6 æ¨¡å—ä¸æ˜¯å¯¹è±¡ï¼Œå®ƒçš„å¯¹å¤–æ¥å£åªæ˜¯ä¸€ç§é™æ€å®šä¹‰ï¼Œåœ¨ä»£ç é™æ€è§£æé˜¶æ®µå°±ä¼šç”Ÿæˆã€‚

CommonJSæ¨¡å—çš„åŠ è½½æœºåˆ¶æ˜¯ï¼Œè¾“å…¥çš„æ˜¯è¢«è¾“å‡ºçš„å€¼çš„æ‹·è´ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€æ—¦è¾“å‡ºä¸€ä¸ªå€¼ï¼Œæ¨¡å—å†…éƒ¨çš„å˜åŒ–å°±å½±å“ä¸åˆ°è¿™ä¸ªå€¼ã€‚è¿™ç‚¹ä¸ES6æ¨¡å—åŒ–æœ‰é‡å¤§å·®å¼‚

ESM Firstï¼šæ— è®ºä»€ä¹ˆæ¨¡å—ï¼Œä¼˜å…ˆæ„å»ºå‡º ESM æ ¼å¼ã€‚å¤šå…¥å£åŒ…ä½¿ç”¨ exports ã€browserï¼ˆè‹¥ webpack < 5ï¼‰ï¼Œå•å…¥å£ä½¿ç”¨ mainã€module å¯å¤„ç†å¤§éƒ¨åˆ†æ¨¡å—æ ¼å¼é—®é¢˜



å‚è€ƒæ–‡ç« ï¼š

https://github.com/joelparkerhenderson/monorepo-vs-polyrepo